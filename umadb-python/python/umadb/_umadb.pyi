# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class AppendCondition:
    r"""
    Python wrapper for DCBAppendCondition
    """
    def __new__(cls, fail_if_events_match: Query, after: typing.Optional[builtins.int] = None) -> AppendCondition: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Client:
    r"""
    Python wrapper for the synchronous UmaDB client
    """
    def __new__(cls, url: builtins.str, ca_path: typing.Optional[builtins.str] = None, batch_size: typing.Optional[builtins.int] = None, api_key: typing.Optional[builtins.str] = None) -> Client:
        r"""
        Create a new UmaDB client
        
        Args:
            url: The server URL (e.g., "http://localhost:50051" or "https://server:50051")
            ca_path: Optional path to CA certificate for TLS
            batch_size: Optional batch size for reading events
            api_key: Optional API key for authenticating clients
        
        
        Returns:
            A connected UmaDB client
        """
    def read(self, query: typing.Optional[Query] = None, start: typing.Optional[builtins.int] = None, backwards: builtins.bool = False, limit: typing.Optional[builtins.int] = None, subscribe: builtins.bool = False) -> ReadResponse:
        r"""
        Read events from the event store
        
        Args:
            query: Optional Query to filter events
            start: Optional starting position
            backwards: Whether to read backwards (default: False)
            limit: Optional maximum number of events to read
            subscribe: Whether to subscribe to new events (default: False)
        
        Returns:
            List of SequencedEvent objects
        """
    def subscribe(self, query: typing.Optional[Query] = None, after: typing.Optional[builtins.int] = None) -> Subscription:
        r"""
        Subscribe to events from the event store
        
        This method returns optionally filtered events after
        an optional position. The returned iterator yields
        events indefinitely until canceled or the stream ends.
        
        Args:
            query: Optional tags and types filter
            after: Optional position filter
        
        Returns:
            An iterable of SequencedEvent objects
        """
    def head(self) -> typing.Optional[builtins.int]:
        r"""
        Get the current head position of the event store
        
        Returns:
            Optional position (None if store is empty)
        """
    def append(self, events: typing.Sequence[Event], condition: typing.Optional[AppendCondition] = None, tracking_info: typing.Optional[TrackingInfo] = None) -> builtins.int:
        r"""
        Append events to the event store
        
        Args:
            events: List of Event objects to append
            condition: Optional AppendCondition
            tracking_info: Optional TrackingInfo
        
        Returns:
            Position of the last appended event
        """
    def get_tracking_info(self, source: builtins.str) -> typing.Optional[builtins.int]:
        r"""
        Get the recorded tracking position for a source
        
        Args:
            source: The tracking source identifier
        
        Returns:
            Optional position last recorded for this source (None if not set)
        """
    def __repr__(self) -> builtins.str: ...

@typing.final
class Event:
    r"""
    Python wrapper for DCBEvent
    """
    @property
    def event_type(self) -> builtins.str: ...
    @property
    def data(self) -> bytes: ...
    @property
    def tags(self) -> builtins.list[builtins.str]: ...
    @property
    def uuid(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, event_type: builtins.str, data: typing.Sequence[builtins.int], tags: typing.Optional[typing.Sequence[builtins.str]] = None, uuid: typing.Optional[builtins.str] = None) -> Event: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Query:
    r"""
    Python wrapper for DCBQuery
    """
    def __new__(cls, items: typing.Optional[typing.Sequence[QueryItem]] = None) -> Query: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class QueryItem:
    r"""
    Python wrapper for DCBQueryItem
    """
    def __new__(cls, types: typing.Optional[typing.Sequence[builtins.str]] = None, tags: typing.Optional[typing.Sequence[builtins.str]] = None) -> QueryItem: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class ReadResponse:
    r"""
    Python iterator over sequenced events
    """
    def __iter__(self) -> ReadResponse: ...
    def __next__(self) -> SequencedEvent: ...
    def head(self) -> typing.Optional[builtins.int]:
        r"""
        Returns the current head position of the event store, or None if empty
        """
    def collect_with_head(self) -> tuple[builtins.list[SequencedEvent], typing.Optional[builtins.int]]:
        r"""
        Collects all remaining events along with the head position
        """
    def next_batch(self) -> builtins.list[SequencedEvent]:
        r"""
        Returns the next batch of events for this read. If there are no more events, returns an empty list.
        """

@typing.final
class SequencedEvent:
    r"""
    Python wrapper for DCBSequencedEvent
    """
    @property
    def event(self) -> Event: ...
    @property
    def position(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Subscription:
    r"""
    Python iterator over sequenced events
    """
    def __iter__(self) -> Subscription: ...
    def __next__(self) -> SequencedEvent: ...
    def next_batch(self) -> builtins.list[SequencedEvent]:
        r"""
        Returns the next batch of events for this read. If there are no more events, returns an empty list.
        """

@typing.final
class TrackingInfo:
    @property
    def source(self) -> builtins.str: ...
    @property
    def position(self) -> builtins.int: ...
    def __new__(cls, source: builtins.str, position: builtins.int) -> TrackingInfo: ...
    def __repr__(self) -> builtins.str: ...



class IntegrityError(ValueError):
    """Raised when the event store detects integrity violations."""
    ...

class TransportError(RuntimeError):
    """Raised when the client fails to communicate with the server."""
    ...

class CorruptionError(RuntimeError):
    """Raised when on-disk data corruption is detected."""
    ...

class AuthenticationError(RuntimeError):
    """Raised when on-disk data corruption is detected."""
    ...
